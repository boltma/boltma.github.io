<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MXY</title>
  <icon>https://www.gravatar.com/avatar/7579ff0a6debdeffbd6b61338d58fb72</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://boltma.github.io/"/>
  <updated>2019-12-03T04:10:33.872Z</updated>
  <id>http://boltma.github.io/</id>
  
  <author>
    <name>mxy</name>
    <email>maxy18@mails.tsinghua.edu.cn</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Fisher Information</title>
    <link href="http://boltma.github.io/2019/05/02/Fisher-Information/"/>
    <id>http://boltma.github.io/2019/05/02/Fisher-Information/</id>
    <published>2019-05-02T14:49:24.000Z</published>
    <updated>2019-12-03T04:10:33.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fisher-information">Fisher Information</h1><p><strong>Fisher Information（费希尔信息）</strong>是用以衡量观测数据所蕴含的数据量，具体说来是指观测所得的随机变量<span class="math inline">\(X\)</span>携带的关于未知参数<span class="math inline">\(\theta\)</span>的信息量，其中<span class="math inline">\(X\)</span>的概率分布依赖于<span class="math inline">\(\theta\)</span>，通常记作<span class="math inline">\({\mathcal {I}}_{X}(\theta)\)</span>。</p><p>对于概率分布<span class="math inline">\(f(X;\theta)\)</span>（满足<span class="math inline">\(f(x;\theta )\geq0, \int f(x;\theta )dx=1,\quad\forall\theta\in\Theta\)</span>，<span class="math inline">\(\Theta\)</span>为参数集），称对数似然函数关于<span class="math inline">\(\theta\)</span>的偏导<span class="math inline">\(\frac {\partial }{\partial \theta }\log f(X;\theta )\)</span>为其<strong>得分</strong>（Score function），对于真实的参数<span class="math inline">\(\theta\)</span>，则有此得分的期望为0：</p><p><span class="math inline">\({\displaystyle {\begin{aligned}\operatorname {E} \left[\left.{\frac {\partial }{\partial \theta }}\log f(X;\theta )\right|\theta \right]&amp;=\int {\frac { {\frac {\partial }{\partial \theta }}f(x;\theta )}{f(x;\theta )}}f(x;\theta )\,dx\\&amp;={\frac {\partial }{\partial \theta }}\int f(x;\theta )\,dx\\&amp;={\frac {\partial }{\partial \theta }}1=0.\end{aligned}}}\)</span></p><p>并将得分的方差定义为<strong>费希尔信息</strong>：</p><p><span class="math inline">\({\displaystyle {\mathcal {I}}(\theta )=\operatorname {E} \left[\left.\left({\frac {\partial }{\partial \theta }}\log f(X;\theta )\right)^{2}\right|\theta \right]=\int \left({\frac {\partial }{\partial \theta }}\log f(x;\theta )\right)^{2}f(x;\theta )\,dx}\)</span></p><p>并且在密度函数具有良好性质的情况下，可以用分部积分很容易证明：</p><p><span class="math inline">\({\mathcal {I}}(\theta )=-\operatorname {E} \left[\left.{\frac {\partial ^{2}}{\partial \theta ^{2}}}\log f(X;\theta )\right|\theta \right]\)</span></p><p>这个表达式以如下方式表达了观测所携带的信息量：若对数似然函数较为平坦，则我们对<span class="math inline">\(\theta\)</span>的估计较差，反之，若对数似然函数有高而窄的峰，则我们可以得到对<span class="math inline">\(\theta\)</span>的较好估计，而这个性状由负二阶导数表征。</p><p>由于n个样本的对数似然函数为单个似然函数之和，容易证明，n个独立同分布样本的费希尔信息是单个样本的费希尔信息的n倍。</p><p>费希尔信息的三种观点：</p><ul><li>得分（对数似然函数的偏导）的方差</li><li>对数似然函数负二阶偏导的期望</li><li>最大似然估计渐近分布的方差的倒数</li></ul><h1 id="cramér-rao-bound">Cramér-Rao Bound</h1><p>费希尔信息的重要性在于<strong>Cramér-Rao不等式</strong>，或<strong>Cramér-Rao Bound（克拉美罗界）</strong>：</p><p>费希尔信息的倒数是参数<span class="math inline">\(\theta\)</span>的任何无偏估计<span class="math inline">\(\hat\theta\)</span>的方差的下界，即<span class="math inline">\(\operatorname {var} ({\hat {\theta }})\geq {\frac {1}{\mathcal {I}(\theta )}}\)</span></p><blockquote><p>关于参数<span class="math inline">\(\theta\)</span>的估计<span class="math inline">\(\hat\theta\)</span>的偏定义为估计的误差的期望值，即<span class="math inline">\(\operatorname {Bias} _{\theta }[\,{\hat {\theta }}\,]=\operatorname {E} _{\theta }[\,{\hat {\theta }}\,]-\theta =\operatorname {E} _{\theta }[\,{\hat {\theta }}-\theta \,]\)</span>，其中<span class="math inline">\(\operatorname {E} _{\theta }\)</span>表示期望是相对密度函数<span class="math inline">\(f(X;\theta)\)</span>而言的。</p><p>若对于所有<span class="math inline">\(\theta\in\Theta\)</span>，偏为0，则称此估计为无偏估计。</p><p>例如样本均值是总体均值的无偏估计量，样本方差是总体方差的无偏估计量，而标准差是总体标准差的有偏估计量。</p></blockquote><p>估计无偏并不能保证误差以极大的概率是低的。例如对于正态分布<span class="math inline">\({\mathcal {N}}(\theta ,1)\)</span>，设<span class="math inline">\(X_1,X_2,\cdots,X_n\)</span>是抽自它的独立同分布样本。估计<span class="math inline">\(\theta\)</span>时，<span class="math inline">\(X_1\)</span>与<span class="math inline">\(\bar {X_n}\)</span>均为无偏估计，然而显然使用更多数据会得到更好的估计，事实上也可以证明<span class="math inline">\(\bar {X_n}\)</span>是最小方差无偏估计量，也即达到了<strong>克拉美罗界</strong>。</p><p>达到克拉美罗界的无偏估计量优越于其他所有估计，也即<span class="math inline">\({\displaystyle \operatorname{E}[(\hat\theta_1(X_1,X_2,\cdots,X_n)-\theta)^{2}]\leq\operatorname{E}[(\hat\theta_2(X_1,X_2,\cdots,X_n)-\theta)^{2}]}\)</span>，若<span class="math inline">\(\hat\theta_1\)</span>达到了克拉美罗界。</p><p><strong>Cramér-Rao不等式的证明：</strong></p><p>设<span class="math inline">\(V\)</span>是得分函数，<span class="math inline">\(\hat\theta\)</span>是估计量。由Cauchy-Schwartz不等式，可得</p><p><span class="math display">\[\operatorname{E}_\theta[(V-\operatorname{E}_\theta V)(\hat\theta-\operatorname{E}_\theta\hat\theta)] \leq \operatorname{E}_\theta(V-\operatorname{E}_\theta V)^2\operatorname{E}_\theta(\hat\theta-\operatorname{E}_\theta \hat\theta)^2\]</span></p><p>由于<span class="math inline">\(\hat\theta\)</span>是无偏估计，所以对于任意<span class="math inline">\(\theta\)</span>均有<span class="math inline">\(\operatorname{E}_\theta \hat\theta=\theta\)</span>，同时得分函数的期望也为零（见上），并且结合费希尔信息的定义（<span class="math inline">\({\mathcal {I}}(\theta )=\operatorname {E}[V^2]\)</span>），代入上式有<span class="math inline">\(\operatorname {E}_\theta[V\hat\theta]\leq\mathcal{I}(\theta)\operatorname{var}(\hat\theta).\)</span></p><p>而</p><p><span class="math display">\[{\displaystyle \begin{aligned} \operatorname {E}_\theta[V\hat\theta]&amp;=\int\frac{\frac{\partial}{\partial\theta}f(x;\theta)}{f(x;\theta)}\hat\theta(x)f(x;\theta)dx \\ &amp;= \int \frac{\partial}{\partial\theta} f(x;\theta)\hat\theta(x)dx \\ &amp;= \frac{\partial}{\partial\theta}\int f(x;\theta)\hat\theta(x)dx \\ &amp;= \frac{\partial}{\partial\theta} \operatorname{E}_\theta[\hat\theta] \\ &amp;= \frac{\partial}{\partial\theta}\theta = 1\end{aligned}}\]</span></p><p>（这里能交换积分与微分号是假定密度函数具有良好性质，上同）</p><p>代入即得到Cramér-Rao不等式。 <span class="math inline">\(\square\)</span></p><p>以相同的证明方式可以得到对于任意估计量有<span class="math inline">\(\operatorname {var} \left({\hat {\theta }}\right)\geq {\frac {[1+b&#39;(\theta )]^{2}}{\mathcal{I}(\theta )}}\)</span>，此处<span class="math inline">\(b(\theta)=\operatorname{E}_\theta[\hat\theta]-\theta.\)</span></p><h1 id="多参数情形的fisher-information">多参数情形的Fisher Information</h1><p>多参数下有<strong>费希尔信息矩阵</strong><span class="math inline">\(\mathcal{I}(\theta)\)</span>，其中元素为<span class="math inline">\(\mathcal{I}_{m,k}=\operatorname {E} \left[{\frac {\partial }{\partial \theta _{m}}}\log f\left(x;\theta\right){\frac {\partial }{\partial \theta _{k}}}\log f\left(x;\theta\right)\right]=-\operatorname {E} \left[{\frac {\partial ^{2}}{\partial \theta _{m}\partial \theta _{k}}}\log f\left(x;\theta\right)\right]\)</span></p><p><strong>Cramér-Rao不等式</strong>变为：<span class="math inline">\(\Sigma\geq\mathcal{I}^{-1}(\theta)\)</span>，这里矩阵不小于号指差是半正定的，<span class="math inline">\(\Sigma\)</span>是关于<span class="math inline">\(\theta\)</span>的一组无偏估计量的协方差矩阵。</p><h1 id="与其它散度测度的关系">与其它散度测度的关系</h1><h2 id="与熵的关系">与熵的关系</h2><p>以<span class="math inline">\(f(x)\)</span>为密度函数的随机变量<span class="math inline">\(X\)</span>的微分熵（differential entropy）定义为：</p><p><span class="math display">\[h(x)=-\int_{S}f(x)\log f(x)dx\]</span> 对<span class="math inline">\(\epsilon&gt;0\)</span>及任意<span class="math inline">\(n\)</span>，定义<span class="math inline">\(f(x)\)</span>的典型集<span class="math inline">\(A_{\epsilon}^{(n)}\)</span>如下：</p><p><span class="math display">\[\begin{aligned} A_{\epsilon}^{(n)}=\{&amp;(x_1,x_2,\cdots,x_n)\in S^n: \\ &amp;\left|-\frac{1}{n}\log f(x_1,x_2,\cdots,x_n)-h(X)\right|\leq\epsilon \} \end{aligned}\]</span> 这里<span class="math inline">\(f(x_1,x_2,\cdots,x_n) = \prod\limits_{i=1}^{n}f(x_i)\)</span></p><p>典型集是所有概率<span class="math inline">\(\geq1-\epsilon\)</span>的集合中体积最小的。</p><p>熵表征了典型集的体积（典型集体积渐近趋于<span class="math inline">\(2^{nh}\)</span>，其中<span class="math inline">\(h\)</span>为熵），而费希尔信息与典型集的表面积相关。</p><h2 id="de-bruijn恒等式">de Bruijn恒等式</h2><p>设<span class="math inline">\(X\)</span>为任一随机变量，其密度函数为<span class="math inline">\(f(x)\)</span>且方差有限。令<span class="math inline">\(Z\)</span>是与<span class="math inline">\(X\)</span>独立的正态分布的随机变量，均值为0，方差为1。则：</p><p><span class="math display">\[\frac{\partial}{\partial t}h_e(X+\sqrt{t}Z)=\frac{1}{2}\mathcal{I}(X+\sqrt{t}Z)\]</span></p><p>此处<span class="math inline">\(h_e\)</span>表明微分熵公式中底数为<span class="math inline">\(e\)</span>，费希尔信息是关于随机变量分布的费希尔信息。特别地，若<span class="math inline">\(t\rightarrow 0\)</span>时极限存在，则<span class="math inline">\(\frac{\partial}{\partial t}h_e(X+\sqrt{t}Z)\big|_{t=0}=\frac{1}{2}\mathcal{I}(X)\)</span></p><p>通常<span class="math inline">\(t\)</span>被视作一种扰动。</p><h2 id="卷积不等式">卷积不等式</h2><p><span class="math display">\[\frac{1}{\mathcal{I}(X+Y)} \geq \frac{1}{\mathcal{I}(X)} + \frac{1}{\mathcal{I}(Y)}\]</span></p><h2 id="熵幂不等式">熵幂不等式</h2><p>设<span class="math inline">\(\mathbf{X}\)</span>和<span class="math inline">\(\mathbf{Y}\)</span>为相互独立的<span class="math inline">\(n\)</span>维随机向量，它们的密度函数已知，则：</p><p><span class="math display">\[2^{\frac{2}{n}h(\mathbf{X}+\mathbf{Y})}\geq 2^{\frac{2}{n}h(\mathbf{X})}+2^{\frac{2}{n}h(\mathbf{Y})}\]</span></p><p>对于两个独立的随机变量<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>，<span class="math inline">\(h(X+Y)\geq h(X&#39;+Y&#39;)\)</span>，这里<span class="math inline">\(X&#39;\)</span>和<span class="math inline">\(Y&#39;\)</span>是相互独立的正态分布的随机变量，且满足<span class="math inline">\(h(X&#39;)=h(X)\)</span>且<span class="math inline">\(h(Y&#39;)=h(Y)\)</span>。</p><h1 id="fisher-information-natural-gradient">Fisher Information &amp; Natural Gradient</h1><p>在概率分布函数具备良好性质时，Fisher信息矩阵和KL散度的Hesse矩阵的相反数相等。因而在牛顿迭代法中，使用Fisher信息矩阵代替Hesse矩阵，有时更易求解。</p><blockquote><p><strong>Natural Gradient（自然梯度法）</strong></p><p><span class="math display">\[{\displaystyle \theta _{m+1}=\theta _{m}+\eta_m{\mathcal {I}}^{-1}(\theta _{m})V(\theta _{m})}\]</span></p><p>（<span class="math inline">\(V\)</span>为关于<span class="math inline">\(\theta\)</span>的得分函数）</p></blockquote><p>自然梯度法考虑了参数的不同维度对目标函数不同的影响，加速了梯度下降法的收敛。</p><p>SGD（随机梯度下降）中，假设中心极限定理，随机梯度作为一个随机变量，满足正态分布。那么迭代中，相当于使用全部数据计算的梯度，附加上协方差矩阵，即：（<span class="math inline">\(t\)</span>为mini-batch的规模）</p><p><span class="math display">\[{\displaystyle \theta _{m+1}=\theta _{m}+\eta_m V_0(\theta _{m})}+\frac{\eta_m}{\sqrt{t}}\epsilon_m, \epsilon_m\sim\mathcal{N}(0,\hat{\Sigma}(\theta_m))\]</span></p><p>上式中，协方差与目标函数的曲率在真实参数上相等。而在迭代过程中也近似相等。</p><p>这表明这样的SGD中的噪声遵循目标函数的曲率，使得迭代时更容易逃离局部的sharp minima，进入flat minima，从而得到泛化能力更强的解。因而使用自然梯度的随机梯度下降能获得更强的泛化能力，也通常能加快迭代速度。</p><h1 id="references">References</h1><ol type="1"><li><p>Wikipedia contributors, &quot;Fisher information —— Wikipedia, the free encyclopedia,&quot; 2019. [Online; accessed 24-May-2019].</p></li><li><p>T. M. Cover and J. A. Thomas, <em>Elements of information theory.</em> John Wiley &amp; Sons, 2012.</p></li><li><p>J. Duchi, &quot;Lecture notes for statistics 311/electrical engineering 377,&quot; URL:<a href="https://stanford.edu/class/stats311/Lectures/full_notes.pdf" class="uri" target="_blank" rel="noopener">https://stanford.edu/class/stats311/Lectures/full_notes.pdf</a> . Last visited on, vol. 2, p. 23, 2016.</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;fisher-information&quot;&gt;Fisher Information&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Fisher Information（费希尔信息）&lt;/strong&gt;是用以衡量观测数据所蕴含的数据量，具体说来是指观测所得的随机变量&lt;span clas
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>形式语言与自动机</title>
    <link href="http://boltma.github.io/2019/03/24/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <id>http://boltma.github.io/2019/03/24/形式语言与自动机/</id>
    <published>2019-03-24T01:54:17.000Z</published>
    <updated>2019-12-03T04:10:33.881Z</updated>
    
    <content type="html"><![CDATA[<h1 id="上下文无关文法">上下文无关文法</h1><h2 id="设计上下文无关文法">设计上下文无关文法</h2><ol type="1"><li><p>{a<sup>n</sup>b<sup>n</sup>c<sup>m</sup>d<sup>m</sup>|n≥1,m≥1}∩{a<sup>n</sup>b<sup>m</sup>c<sup>m</sup>d<sup>n</sup>|n≥1,m≥1}</p><p>S-&gt;AB|T T-&gt;aTd|aCd A-&gt;aAb|ab B-&gt;cBd|cd C-&gt;bCc|bc</p></li><li><p>{a<sup>n</sup>b<sup>m</sup>|n,m≥0∧n≥m}</p><p>S-&gt;A|B A-&gt;aA|aC B-&gt;Bb|Cb C-&gt;aCb|ε</p></li><li><p>{a<sup>n</sup>b<sup>m</sup>|n≥0,m≥0,3n≥m≥2n}</p><p>S-&gt;aSbb|aSbbb|ε</p></li><li><p>{w|w∈{a,b}<sup>*</sup>,w中a和b的数目不同}</p><p>S-&gt;A|B A-&gt;AA|Ta B-&gt;BB|Tb T-&gt;aTbT|bTaT|ε 注意此处T生成a与b数目相同的字符串</p></li><li><p>{w|w∈{a,b}<sup>*</sup>,且w中a与b的数目相差为2}</p><p>S-&gt;TaTaT|TbTbT T-&gt;aTbT|bTaT|ε</p></li></ol><h2 id="文法和语言中的二义性">文法和语言中的二义性</h2><p><em>文法无二义性：语法分析树唯一，亦等价于最左推导唯一</em></p><ol type="1"><li><p>下面的文法生成的是具有x和y的操作数、二元运算符+、-和*的前缀表达式：</p><p>E-&gt;+EE|*EE|-EE|x|y</p><p>证明这个文法是无歧义的。（Hopcroft, 5.4.7(b)）</p><p>提纲：可证明其最左推导是唯一的，对字符串长度归纳，同时归纳证明生成的字符串w所有非空后缀字符串中操作数个数多于运算符个数。</p></li></ol><h1 id="有限自动机">有限自动机</h1><p>安利一个用来画自动机的app：<a href="http://madebyevan.com/fsm/" class="uri" target="_blank" rel="noopener">http://madebyevan.com/fsm/</a></p><h2 id="设计dfa">设计DFA</h2><ol type="1"><li>长度至少为2且头两个字符不相同的0,1串构成的集合</li></ol><table><thead><tr class="header"><th></th><th>0</th><th>1</th></tr></thead><tbody><tr class="odd"><td>-&gt;q0</td><td>q1</td><td>q2</td></tr><tr class="even"><td>q1</td><td>q4</td><td>q3</td></tr><tr class="odd"><td>q2</td><td>q3</td><td>q4</td></tr><tr class="even"><td>*q3</td><td>q3</td><td>q3</td></tr><tr class="odd"><td>q4</td><td>q4</td><td>q4</td></tr></tbody></table><ol start="2" type="1"><li>{w∈{a,b}<sup>*</sup>|w中不包含子串aa}</li></ol><table><thead><tr class="header"><th></th><th>a</th><th>b</th></tr></thead><tbody><tr class="odd"><td>-&gt;*q0</td><td>q1</td><td>q0</td></tr><tr class="even"><td>*q1</td><td>q2</td><td>q0</td></tr><tr class="odd"><td>q2</td><td>q2</td><td>q2</td></tr></tbody></table><ol start="3" type="1"><li>{w∈{a,b}<sup>*</sup>|w中包含且仅包含奇数个子串ab}</li></ol><table><thead><tr class="header"><th></th><th>a</th><th>b</th></tr></thead><tbody><tr class="odd"><td>-&gt;q0</td><td>q1</td><td>q0</td></tr><tr class="even"><td>q1</td><td>q1</td><td>q2</td></tr><tr class="odd"><td>*q2</td><td>q3</td><td>q2</td></tr><tr class="even"><td>q3</td><td>q3</td><td>q0</td></tr></tbody></table><ol start="4" type="1"><li>{w∈{a,b}<sup>*</sup>|w中a的个数和b的个数之和是奇数}</li></ol><table><thead><tr class="header"><th></th><th>a</th><th>b</th></tr></thead><tbody><tr class="odd"><td>-&gt;q0</td><td>q1</td><td>q1</td></tr><tr class="even"><td>*q1</td><td>q0</td><td>q0</td></tr></tbody></table><ol start="5" type="1"><li>{w∈{a,b}<sup>*</sup>|w含相同个数的a和b,且w的每个前缀中a和b个数之差不超过1}</li></ol><table><thead><tr class="header"><th></th><th>a</th><th>b</th></tr></thead><tbody><tr class="odd"><td>-&gt;*q0</td><td>q1</td><td>q2</td></tr><tr class="even"><td>q1</td><td>q3</td><td>q0</td></tr><tr class="odd"><td>q2</td><td>q0</td><td>q3</td></tr><tr class="even"><td>q3</td><td>q3</td><td>q3</td></tr></tbody></table><ol start="6" type="1"><li>{w∈{a,b}<sup>*</sup>|w包含子串ab，但不包含子串bb}</li></ol><p><img src="/2019/03/24/形式语言与自动机/dfa-1.png"></p><p>相应的NFA有：</p><p><img src="/2019/03/24/形式语言与自动机/nfa-1.png"></p><p>此NFA遇到子串ab时到达终态，如果是最后一个ab，则停留在终态，反之跳转回q1。</p><h2 id="dfa的最小化">DFA的最小化</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/24/形式语言与自动机/dfa-2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>构造与该DFA等价的最小化的DFA：</p><p>填表算法第一步区分1，3，6与2，4，5</p><p>第二步区分2与4，5（输入字符b）</p><p>第三步区分1，3与6（输入字符a）</p><p>故最终等价类有{1, 3}, {2}, {4, 5}, {6}</p><p>最小化的DFA是</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/24/形式语言与自动机/dfa-3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="正规语言">正规语言</h1><h2 id="设计正规语言">设计正规语言</h2><ol type="1"><li><p>{xwx<sup>R</sup>|x,w∈(a+b)+},其中(a+b)<sup>+</sup>=(a+b)(a+b)<sup>*</sup>,x<sup>R</sup>为x的反向(即反转)</p><p>a(a+b)(a+b)<sup>*</sup>a+b(a+b)(a+b)<sup>*</sup>(a+b)</p></li><li><p>{w|w∈{a,b}<sup>*</sup>∧∃x,y(x,y∈{a,b}<sup>*</sup>∧w=xy∧|y|=3∧y=y<sup>R</sup>)}</p><p>(a+b)<sup>*</sup>(aaa+aba+bab+bbb)</p></li><li><p>{w∈{a,b}<sup>*</sup>|w中既不包含子串aa,也不包含子串bb}</p><p>(ε+b)(ab)<sup>*</sup>(ε+a)</p></li><li><p>{a<sup>n</sup>b<sup>m</sup>|n,m≥0且n+m为偶数}</p><p>(aa)<sup>*</sup>(bb)<sup>*</sup>+(aa)<sup>*</sup>a(bb)<sup>*</sup>b</p></li><li><p>{w|w∈{a,b}<sup>*</sup>,|w|≥1,且w的后20位至少有一个a}</p><p>(a+b)<sup>*</sup>a(a+b+ε)<sup>19</sup></p></li><li><p>{w|w∈{a,b}<sup>*</sup>,|w|≥1,且当w以a结尾时,它的长度为奇数}</p><p>((a+b)(a+b))<sup>*</sup>a+(a+b)<sup>*</sup>b</p></li><li><p>{w|w∈{a,b}<sup>*</sup>,|w|≥2,且w的前5位至少有一个子串aa}</p><p>(a+b+ε)<sup>3</sup>aa(a+b)<sup>*</sup></p></li><li><p>{w|w∈{a,b}<sup>*</sup>,|w|≥2,且w的第2位至第5位至少有一个a}</p><p>(a+b)(a+b+ε)<sup>3</sup>a(a+b)<sup>*</sup></p></li><li><p>{w|w∈{0,1}<sup>*</sup>,w至少含有3个1,且倒数第3位为1}</p><p>(0+1)<sup>*</sup>1(0+1)<sup>*</sup>1(0+1)<sup>*</sup>100+(0+1)<sup>*</sup>1(0+1)<sup>*</sup>1(01+10)+(0+1)<sup>*</sup>111</p></li></ol><h2 id="有限状态自动机与正规表达式的关系">有限状态自动机与正规表达式的关系</h2><h3 id="thompson构造法">Thompson构造法</h3><p>略</p><h3 id="kleene构造法状态消去法">Kleene构造法&amp;状态消去法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/24/形式语言与自动机/dfa-4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>运用状态消去法，消2，1到4的弧变为b(a+b)，4到自身的弧变为(a+b)<sup>2</sup></p><p>最终的正则表达式为a<sup>*</sup>+a<sup>*</sup>b(a+b)((a+b)<sup>2</sup>)<sup>*</sup></p><h2 id="正规语言的性质">正规语言的性质</h2><ol type="1"><li><p>语言L由所有满足如下条件的0，1串构成：0的数目二倍于1的数目。试应用Pumping引理证明L不是正规语言。</p><p>对于任意n，取w=0<sup>2n</sup>1<sup>n</sup>，任意满足w=xyz∧|xy|≤n∧y≠ε的x，y，z必有y全由0组成，则xy<sup>0</sup>z中0比1的两倍少，不在L中，L不是正规语言。</p></li><li><p>语言L由所有满足如下条件的0, 1串构成：0的数目多于1的数目（ 对0 和1 在串中出现的次序没有限制）。试应用Pumping引理证明L不是正规语言。</p><p>选w=0<sup>n+1</sup>1<sup>n</sup></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;上下文无关文法&quot;&gt;上下文无关文法&lt;/h1&gt;
&lt;h2 id=&quot;设计上下文无关文法&quot;&gt;设计上下文无关文法&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;{a&lt;sup&gt;n&lt;/sup&gt;b&lt;sup&gt;n&lt;/sup&gt;c&lt;sup&gt;m&lt;/sup&gt;d&lt;sup&gt;m&lt;/sup
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello, world!</title>
    <link href="http://boltma.github.io/2019/03/24/Hello-world/"/>
    <id>http://boltma.github.io/2019/03/24/Hello-world/</id>
    <published>2019-03-24T01:53:12.000Z</published>
    <updated>2019-12-03T04:10:33.877Z</updated>
    
    <content type="html"><![CDATA[<p>这里会记录一些学习笔记，或者灌水，请多多指教！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里会记录一些学习笔记，或者灌水，请多多指教！&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
