<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MXY</title>
  <icon>https://www.gravatar.com/avatar/7579ff0a6debdeffbd6b61338d58fb72</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://boltma.github.io/"/>
  <updated>2019-12-06T06:11:44.724Z</updated>
  <id>http://boltma.github.io/</id>
  
  <author>
    <name>mxy</name>
    <email>maxy18@mails.tsinghua.edu.cn</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RC-NVM技术详解（下）</title>
    <link href="http://boltma.github.io/2019/12/04/RC-NVM%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://boltma.github.io/2019/12/04/RC-NVM技术详解（下）/</id>
    <published>2019-12-04T13:49:36.000Z</published>
    <updated>2019-12-06T06:11:44.724Z</updated>
    
    <content type="html"><![CDATA[<p>本文是HPCA 2018 <em>RC-NVM: Enabling symmetric row and column memory accesses for in-memory databases</em><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>一文的学习总结与分析。这一部分将主要总结RC-NVM的总体架构设计。</p><p>值得注意的是，此架构设计的思路中，并不特定针对RC-NVM的电路设计，因而总体而言适用于不同的对称式存储器。</p><h1 id="rc-nvm架构设计">RC-NVM架构设计</h1><p>内存架构的设计主要涉及：整体架构、寻址、缓存架构以及应用层的数据布局。</p><h2 id="整体架构">整体架构</h2><p>类似于传统DRAM或RRAM内存，RC-NVM整体架构也有channel，DIMM，rank，chip，bank……的层次，关于内存的结构，可参见《<a href="http://lzz5235.github.io/2015/04/21/memory.html" target="_blank" rel="noopener">内存条物理结构分析</a>》一文的介绍。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/04/RC-NVM技术详解（下）/1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>上图为RC-NVM整体架构的一个例子。此图中有一个DIMM，该DIMM中有两个rank，每个rank有八个chip，每个chip由上一篇总结中电路结构所示的bank（含多个RC-NVM子阵列）组成，八个chip合在一起形成64位的存储器总线。按行或按列的读取粒度（granularity）均为8字节。可以在每个rank添加一个chip用以安排纠错码，例如带附加奇偶校验码的汉明码（SECDED），则存储器总线为72位，和传统的DRAM一样。</p><h2 id="寻址">寻址</h2><p>寻址要完成三个目标：</p><ol type="1"><li>两种读取方式的专用地址模式</li><li>显式控制物理内存上的数据布局</li><li>扩展指令集</li></ol><h3 id="双寻址模式">双寻址模式</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/04/RC-NVM技术详解（下）/2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如图所示，(a)中是传统32位主存的地址格式，也即RC-NVM按行读取的地址，其与(b)中按列读取的地址在于：<strong>颠倒了行位和列位</strong>。传统地址格式被完全对称地移植到按列读取的方式上，简化了很多接口、控制器的设计，并且两种读取模式地址间的转换是很容易的。对于按行读取，内存地址增加是增加列位；对于按列读取，内存地址增加是增加行位。</p><h3 id="显式数据布局控制">显式数据布局控制</h3><p>主流操作系统都有内存页的管理机制，现代处理器也支持这些机制。以huge-page（大内存页）技术为例，大内存页可以设为例如1GB，我们让大内存页中虚拟内存地址的低30位与对应物理内存地址低30位完全相同，那么当这低30位包含了行位和列位时（如上一节所示，这是可以做到的），那么分配内存空间时，IMDB（内存数据库）就可以显式地控制数据在物理内存上的布局。实际内存的子阵列（subarray）通常容量小于1GB，因而这样的策略是可以满足我们要求的。这里是以32位内存为例，64位内存是类似的。</p><p>我们为什么需要讨论数据布局的显式控制？事实上这是内存与操作系统接口部分的重要一环。实际的应用中，我们并不满足于直接操纵指针（虚拟地址）。在后面讨论具体应用的数据布局中，我们将看到，为了发挥对称式存储的优势，我们需要拥有显式控制数据布局的能力。我们在这里关心的是什么？是我们需要在操作系统调度、调配物理内存地址的时候，我们能够在应用层面，控制数据在物理内存上的布局。这个解决方式看似简单：直接将物理内存地址与虚拟内存地址直接对应，但需要知道这个对应不是毫无意义的；相反，失去了这个对应的限制，操作系统将直接全盘接管物理内存的调度分配，而我们将在应用层失去调整物理内存分配的可能。我们将在后面看到，像一维内存一样直接将数据按序存储将不是最优的布局方式，对称式存储器是真正二维的，因而针对不同应用进行显式的内存布局是必要的，将布局的能力交给应用处理显然是最合适的——我们不再简单地只在应用层分配内存，把具体数据布局交给操作系统（传统上数据也只需要顺序排列，不必考虑布局），而真正地接管了数据布局。</p><p>实际情况下，RC-NVM设备接入后，设备信息被传给BIOS，IMDB可以从操作系统处获得这些信息并且进行数据布局。</p><h3 id="指令集扩展">指令集扩展</h3><p>这一部分较为简单，我们要增加<code>cload</code>和<code>cstore</code>指令，以利用我们按列读写的新特性。指令可形如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cload reg, addr</span><br><span class="line">cstore reg, addr</span><br></pre></td></tr></table></figure><p>其中<code>reg</code>为目标寄存器，<code>addr</code>为内存地址。指令的实际操作可以通过在行读和行写指令中加入一位信号，标识读写操作是按列的。这在DDR接口中是可以实现的，例如DDR4有两个预留的地址引脚，可以利用其中一个发送此信号。原先指令集中行读、行写仍分别为<code>load</code>和<code>store</code>，其它指令不需调整。</p><h2 id="缓存架构">缓存架构</h2><p>缓存架构主要也有三方面需要调整：</p><ol type="1"><li>双寻址下的缓存存储方式</li><li>单核处理器的缓存同义</li><li>多核处理器的缓存同义与缓存一致性</li></ol><h3 id="双寻址下的缓存存储">双寻址下的缓存存储</h3><p>RC-NVM在两个不同方向上，地址格式都与传统内存相同，因而缓存寻址也可以直接使用传统的方式，解码电路也不必更改。为了区分两个不同方向的地址，缓存中需要增加一个<strong>方向位</strong>（orientation bit），按行读取的数据方向位置0，按列读取的数据方向位置1。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/04/RC-NVM技术详解（下）/3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>上图给出一个缓存的例子，第437行，182列的数据按先前的地址格式，按行读取为0x0036a5b0，按列读取为0x0016cda8，此处行位与列位均占10位，其余位为0。</p><p>这个例子中缓存大小64KB，块大小为64字节，4路相联，具体不再赘述，和传统缓存一致。每次按行读取某8字节数据时，将此子阵列中整行其它56字节一起读入缓存，同时置该缓存项的方向位为0；按列读取类似。</p><h3 id="单核处理器的缓存同义问题">单核处理器的缓存同义问题</h3><p>缓存同义（cache synonym）问题是指：按行读入缓存的数据与按列读入缓存的数据，交叉处的数据被存放在了两个缓存块中，而需要保持二者的同步。</p><p>在RC-DRAM的工作<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>中，提出了WURF 缓存一致性协议，以取代传统的MESI协议。RC-NVM的工作中提出了另一种方式：在缓存块中，给每个8字节（读取粒度）增加一位标识位，用以表示是否是交叉格，称为<strong>交叉位</strong>（crossing bit）。对每个64字节的缓存块，需要额外8位交叉位。在上图中有显示，对于缓存中读取的一行，其每8字节对应的交叉位指代缓存中是否有对应列存储其中。</p><p>总体而言，解决缓存同义，是要使得交叉处的数据同步更新。具体地，需要进行以下额外操作以保持同步：</p><ul><li>当一个缓存块被载入缓存中，缓存控制器检查所有可能与此块交叉的行或列，并置交叉位，如果有交叉，那么交叉处的数据<strong>应由对应的缓存中复制而来</strong>（以保持同步）。例如上图，读取图示行时，检查所有8列，发现4列在缓存中，因而有四位交叉位置1。</li><li>当一个缓存块被从缓存中驱逐时，其交叉的行或列对应交叉位置0。</li><li>当一个缓存块在写操作中被更新，而更新位置对应的交叉位为1，对应的另一个缓存块同时更新数据。</li></ul><h3 id="多核处理器的缓存同义问题与缓存一致性问题">多核处理器的缓存同义问题与缓存一致性问题</h3><p>缓存一致性（cache coherence）问题是指：多核处理器各个私有缓存中存储同一份内存数据时，需要保持同步。</p><p>多核处理器中，既有缓存同义问题，又有缓存一致性问题。我们遵循以下原则：<strong>先处理缓存同义问题，再使用缓存一致性协议</strong>。</p><p>传统的缓存一致性协议主要分为监听式与目录式，此处不介绍细节。监听式主要通过监听其它处理器的缓存读写来调整自身的状态；目录式有一个主处理器以协调其它处理器的缓存，主处理器持有一个目录记录其它处理器的缓存信息。两种方式各有优劣，此处不做比较。对于RC-NVM，采用何种一致性协议是不重要的。</p><p>处理缓存同义问题的方式在上一节中已经叙述，对于多核是一样的。此处交叉位的值是否应该被视作缓存的一部分而应用缓存一致性协议呢？稍加思考可以知道：目录式的一致性协议需要将交叉位存于目录中，而监听式的协议需要将交叉位看为缓存块的一部分在各个核中同步更新。</p><p>处理完缓存同义问题后，我们再使用缓存一致性协议（例如MESI协议等），以保证各个核的缓存同步。注意到使用缓存一致性协议并不会引入新的缓存同义问题，因为缓存一致性问题仅涉及缓存块（某特定方向）的数据的同步，另一个方向应该已在先前的缓存同义中保证了交叉点的一致。另外，现有的缓存一致性协议不必修改。</p><p>另外，单核和多核情况下，从缓存读的操作均没有额外开销；写回额外开销不大；数据替换（更新）操作开销较大，但这本来开销就较大，故可以接受。（此部分开销的分析存疑，这里缓存读写的主要开销究竟是哪一项？）</p><h2 id="具体应用">具体应用</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/04/RC-NVM技术详解（下）/4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这是一个IMDB应用例，在这个应用中，如上所示，有16个数据项，每项4个字段，每个字段8字节，右侧的内存子阵列共含512字节，以如上布局存储16项数据。我们以以下几个应用为例说明RC-NVM的优势：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1for (int i = 1; i &lt;= 16; i++) &#123;</span><br><span class="line">2if (table-&gt;tuple[i].f3 &lt; 1234)</span><br><span class="line">3Print f1, f2, f3, f4 of tuple[i];</span><br><span class="line">4&#125;</span><br><span class="line"></span><br><span class="line">SELECT * FROM table WHERE f3 &lt; ‘1234’</span><br></pre></td></tr></table></figure><p>这是一个OLTP应用，选取所有f3字段小于'1234'的数据项，传统上按行依次读取比较，在RC-NVM上也是按行读取，每次读取，行缓冲区中可存两项数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1int sum = 0;</span><br><span class="line">2uint32_t col_addr_1, col_addr_2;</span><br><span class="line">3col_addr_1 = Row2ColAddr(&amp;(table-&gt;tuple[0].f4));</span><br><span class="line">4col_addr_2 = Row2ColAddr(&amp;(table-&gt;tuple[1].f4));</span><br><span class="line">5for (int i = 1; i &lt;= 8; i++) &#123;</span><br><span class="line">6uint64_t f4_1 = column_load(col_addr_1);</span><br><span class="line">7if (f4_1 &lt; 4321)</span><br><span class="line">8sum += f4_1;</span><br><span class="line">9col_addr_1 += 8;</span><br><span class="line">10&#125;</span><br><span class="line">11for (int i = 1; i &lt;= 8; i++) &#123;</span><br><span class="line">12uint64_t f4_2 = column_load(col_addr_2);</span><br><span class="line">13if (f4_2 &lt; 4321)</span><br><span class="line">14sum += f4_2;</span><br><span class="line">15col_addr_2 += 8;</span><br><span class="line">16&#125;</span><br><span class="line"></span><br><span class="line">SELECT SUM(f4) FROM table WHERE f4 &lt; ‘4321’</span><br></pre></td></tr></table></figure><p>这是一个OLAP应用，计算全体小于'4321'的f4字段之和。传统上需要读取每一项数据，取出f4，进行比较，然后求和。但是在上面这段代码中，我们可以直接按列读取两列，大幅减小内存读取的次数。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/04/RC-NVM技术详解（下）/5.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>上图中应用是行列混合的。问题与上述OLTP应用类似，但我们也可以利用列读的方式提升效率。这个应用中内存总线上传递的数据均是有用的数据，增加了内存带宽的利用率。</p><h2 id="数据布局">数据布局</h2><p>我们先前提到，我们有必要在应用层对物理内存上的数据分布进行显式的操控，这里具体来讨论。</p><p>数据库通常较大，要存放于内存中，必须进行切割，然后将切割后的块按一定方式放于存储阵列中。切割数据库的技术有很多，例如HDF5<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>，这里不做介绍。这里我们定义，一个<strong>块（chunk）</strong>是RC-NVM中放置数据的一个矩形单元，可以存于RC-NVM的一个子阵列中。换句话说，当一个表大于RC-NVM的子阵列的大小（此文例子是8MB），或者当一行数据的长度大于子阵列的行长（此文例子是8KB）时，就会被切割。第二种情况甚少在实际情况中出现。</p><p>进行切割后，有两个问题需要考虑：块内数据布局与块间数据布局。</p><h3 id="块内数据布局">块内数据布局</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/04/RC-NVM技术详解（下）/6.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>传统上，内存虽然是二维阵列，却实际上是一维的。数据在内存中以左图的方式布局。而对于RC-NVM，有两种布局方式：行向布局与列向布局。</p><p>左图行向布局是传统布局方式，各数据项的行内存地址连续排列，与传统IMDB以及内存分配完全兼容，适合按行的读取方式。但是这种布局方式按列读取效率不高。事实上，虽然我们的存储器支持按列读取，但这样的布局下，按列读得的数据不是按顺序排列的（T1之后是T5）。</p><p>右图列向布局则更适合列向读取，各项数据按列依次排布于内存中。也即，每一项数据本身虽然是横向放置的，但各项数据却是按列排列的。此时，获取各项数据的同一个字段效率大幅度提升，可以直接应用按列读取的方式。</p><p>事实上，OLXP应用应该采用右图的列向布局。因为实际情况中，每项数据长度会远小于RC-NVM的行长，因而每行实际上有较多数据，按列读取数据效率较低，并且，实际情况中连续扫描各项完整数据的需求并不大。</p><h3 id="块间数据布局">块间数据布局</h3><p>块间数据布局是个有意思的问题。由于对每个子阵列而言，行列完全对称，因此数据可以旋转后填入子阵列。我们的目标是：使得填入了至少一块数据的子阵列（也即使用的子阵列）数目尽可能少。实际上这是一个经典的问题：<strong>可旋转的二维在线装箱问题（two-dimensional online bin packing with rotation）</strong>我们可以利用很多已有的工作，例如Fujita的算法<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>来求解这个问题。</p><p>这个问题纯粹是软件级别的，在应用层由数据库内存分配来实现，与硬件无关。</p><h1 id="组缓存优化">组缓存优化</h1><p>当数据需要以特定顺序获取时，行向读取效率会降低。先前介绍的都是字段定长（8字节）的情形，但实际情况中字段未必定长，而且也可能超过按列读取的宽度（8字节），这将降低效率。因而我们要在此研究<strong>宽字段读取（wide field access）</strong>问题。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/04/RC-NVM技术详解（下）/7.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如图所示，数据中含有Email字段，但其跨了RC-NVM的两列，不可分割。简单回顾一下架构：我们有一个覆盖全列的列缓冲区，但缓存块通常并没有那么大（例如只有64字节，即能存储该列中8行的数据），务必需要注意缓存与内存是分离的，它们在两个不同设备中，不能认为它们自然匹配。</p><p>简单地以右侧方式读取（也即两次按列读取）将会使得实际上不可分割的Email字段被分离了。数据以图示的顺序被读取，内存上进行了两次按列读取，但数据被读入的顺序并不正确，当T1至T8的Email被读入时，它们事实上仅获得了一半的数据，对于应用而言，这样的数据是无用的（我们并不能假定这些读过的数据被存下而被后续拼接了，缓存可能会直接将之前的数据丢弃）。列向的读写能够高效遍历整个字段仅当读取顺序不做要求。</p><p>正确的方式是以左侧方式读取，但是这需要做四次按列读取，列缓冲区被替换了三次，造成了极大的浪费，列缓冲区被重复地替换了。要正确获得T1的完整Email字段，我们理应在获得前8字节后，立刻获取后8字节。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/04/RC-NVM技术详解（下）/8.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>读取多个字段的情形也是类似的。实际上，操作本身对于数据的获取顺序是有要求的。同一项数据的f3、f6、f10字段应该被一起取出。这种Z型的读取极大降低了按列读取的效率。另一方面，我们更不应该在这种情况下转投按行读取。</p><p>这也是一种<strong>缓存颠簸（cache thrashing）</strong>。其实这个问题很容易解决，按照两图中右侧的读法，数据本身都已经被取出了，唯一的问题就在于缓存可能驱逐上一次刚读进来的问题。我们采取一种熟知的技术：<strong>缓存固定（cache-pinning）</strong><a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>，具体如下所示：我们按照上述右侧的按列取法，先将T1-T8中所有的前半部分读入缓存，并且固定在缓存中，然后依次如图取完四组数据，数据库从缓存中取走数据，缓存解除对数据的固定，这就是<strong>组缓存（group caching）</strong>。这个操作是纯粹软件层面的，可以由IMDB发出一条组缓存的指令来完成。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/04/RC-NVM技术详解（下）/9.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>利用组缓存技术，我们在读取一块矩形区域数据时，IMDB本身可以做优化，选择按行或按列读取。组缓存的大小对效率的影响在于：组缓存大时，会使得其它数据更有可能缓存不命中，而组缓存大小也不能超过缓存本身容量；组缓存小时则不一定能够起到效果。</p><h1 id="评测">评测</h1><p>此部分略去。如果未来有时间可能考虑补上这项内容。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/04/RC-NVM技术详解（下）/10.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/04/RC-NVM技术详解（下）/11.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>仿真配置与测评的代码如上。</p><p>结果如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/04/RC-NVM技术详解（下）/12.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/04/RC-NVM技术详解（下）/13.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/04/RC-NVM技术详解（下）/14.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/04/RC-NVM技术详解（下）/15.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/04/RC-NVM技术详解（下）/16.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/04/RC-NVM技术详解（下）/17.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/04/RC-NVM技术详解（下）/18.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="相关工作">相关工作</h1><p>具体文献详见原文，此处仅作总结。</p><h2 id="内存数据库优化">内存数据库优化</h2><ul><li>内存相关的处理器流水线停顿分析</li><li>数据布局优化</li><li>软件层面的OLXP，如行列混合存储</li></ul><h2 id="高性能内存架构">高性能内存架构</h2><p>DRAM相关的高性能内存架构也可以移植于RC-NVM上，与此文所述架构结合。</p><ul><li>Redundant Memory Mapping</li><li>SALP</li><li>DRAM与对称式存储的混合架构</li><li>Intel Optane</li></ul><h1 id="总结">总结</h1><p>这是一套完整的从电路到应用层的对称式存储架构设计，在各个层次都有值得学习的地方。总体而言，这样的架构设计充分利用了现有技术，例如与RC-DRAM相比，此架构没有设计新的缓存一致性协议，而是利用了已有的协议。</p><p>并且，架构设计中充分的分层是值得学习的。在分层中值得注意的是，一定不能将各个层次混淆，例如：组缓存策略中，缓存的设计与内存本身读写一定要充分区分，不能认为支持了行与列的内存读写，相应的缓存就必然能够按列拼接数据；数据布局的设计也是类似的。一定要注意，在底层出现了新的设计后，向上的每一层接口都要相应地发生改变，但并不用关心下层的具体细节。</p><p>不能仅满足于电路设计，一个支持对称式访问的存储器并不必然地能够提升应用的性能。本文给出一个好的例子，设计了一个完整的系统，此后的工作应该考虑参考之进行完整的系统设计方才是有意义的。</p><p>总体而言，本文架构设计的思想均是最自然的思想，未必是最好的办法，但大大简化了设计的难度，具体应用上，我认为还有一定的改进空间。在系统设计上，最重要的就是抓大放小，掌握各项内容开销大小的主次才能设计好的系统。</p><h1 id="参考文献">参考文献</h1><section class="footnotes"><hr><ol><li id="fn1"><p>Wang, Peng, et al. &quot;RC-NVM: Enabling symmetric row and column memory accesses for in-memory databases.&quot; <em>2018 IEEE International Symposium on High Performance Computer Architecture (HPCA)</em>. IEEE, 2018.<a href="#fnref1" class="footnote-back">↩</a></p></li><li id="fn2"><p>Chen, Yen-Hao, and Yi-Yu Liu. &quot;Dual-addressing memory architecture for two-dimensional memory access patterns.&quot; <em>Proceedings of the Conference on Design, Automation and Test in Europe</em>. EDA Consortium, 2013.<a href="#fnref2" class="footnote-back">↩</a></p></li><li id="fn3"><p>Folk, Mike, et al. &quot;An overview of the HDF5 technology suite and its applications.&quot; <em>Proceedings of the EDBT/ICDT 2011 Workshop on Array Databases</em>. ACM, 2011.<a href="#fnref3" class="footnote-back">↩</a></p></li><li id="fn4"><p>Fujita, Satoshi, and Takeshi Hada. &quot;Two-dimensional on-line bin packing problem with rotatable items.&quot; <em>Theoretical Computer Science</em> 289.2 (2002): 939-952.<a href="#fnref4" class="footnote-back">↩</a></p></li><li id="fn5"><p>Zyulkyarov, Ferad, et al. &quot;Method for pinning data in large cache in multi-level memory system.&quot; U.S. Patent No. 9,645,942. 9 May 2017.<a href="#fnref5" class="footnote-back">↩</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文是HPCA 2018 &lt;em&gt;RC-NVM: Enabling symmetric row and column memory accesses for in-memory databases&lt;/em&gt;&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RC-NVM技术详解（上）</title>
    <link href="http://boltma.github.io/2019/12/03/RC-NVM%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://boltma.github.io/2019/12/03/RC-NVM技术详解（上）/</id>
    <published>2019-12-03T11:18:31.000Z</published>
    <updated>2019-12-05T10:58:18.747Z</updated>
    
    <content type="html"><![CDATA[<p>RC-NVM是指Row-Column Non-Volatile Memory，是一种新型的对称式非易失存储器架构。本文是HPCA 2018 <em>RC-NVM: Enabling symmetric row and column memory accesses for in-memory databases</em><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>一文的学习总结与分析。</p><h1 id="背景介绍">背景介绍</h1><p>对于关系数据库应用，传统硬盘存储只将小部分数据缓存于内存中，具有高I/O延时，而随着DRAM价格降低、容量提升，IMDB（in-memory database，内存数据库）成为可能。</p><p>关系数据库以二维表格存储数据。数据库应用的工作量主要分为两种：OLTP（on-line transactional processing，联机事务处理）与OLAP（on-line analytical processing，联机分析处理）。其中OLTP主要是对数行的读写过程，并且对延时性能要求较高，主要见于交易处理系统。OLAP主要是大量连续跨行、涉及数列的数据处理，例如求列上数据之和，主要见于数据仓库。</p><p>同时使用这两种处理方式时，内存中就需要同时常驻存储至少两份数据拷贝，同时二者之间的数据同步也导致分析数据与实时数据之间转换的低响应。OLXP技术混合二者，将数据存于同一个数据库中，但这一技术也使得内存读写的效率降低。这其中的主要原因在于：OLTP主要涉及按行读写数据，而OLAP主要涉及按列读写数据。传统内存只有一个维度，提供从零开始的内存地址，只能以一个方向读写数据，并且传统上数据也按行存于内存中，对于OLTP方式更为友好。此时OLAP访问就会出现跨行的访问（strided memory access），这样的访问使得DRAM的行缓冲区与缓存利用率极低。如果对OLAP进行优化，数据按列存储，OLTP就会出现同样的问题。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/03/RC-NVM技术详解（上）/4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>上图为按行存储的数据库的具体形式，其中上半部分展现了一种OLTP操作，下半部分展现了一种OLAP操作，注意到OLAP操作中缓存的利用率较低。</p><p>要解决这一问题，同时支持按行读取与按列读取的内存架构是必要的。现有的技术主要有：GS-DRAM、transposable SRAM、RC-DRAM。</p><h2 id="gs-dram">GS-DRAM</h2><p>Gather-Scatter DRAM<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>是一种十分有趣的内存架构，以后有机会可以再单独写一篇文章介绍。</p><p>参考资料可参见<a href="https://users.ece.cmu.edu/~omutlu/pub/GSDRAM-gather-scatter-dram_vivek-micro15-talk.pptx" class="uri" target="_blank" rel="noopener">https://users.ece.cmu.edu/~omutlu/pub/GSDRAM-gather-scatter-dram_vivek-micro15-talk.pptx</a></p><p>这是在对传统DRAM做极少的改动下，将所读的行中可能需要的列（字段）中数据放于缓存中：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/03/RC-NVM技术详解（上）/1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/03/RC-NVM技术详解（上）/2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如上所示，缓存中存储的并非是按行读取的数据，而是跨行的字段，这样的架构可以做到行、列都具有较高的效率。具体而言，通过以下两个技术，可以使得每行的数据中对应的同一列（字段）地址错开，这样可以存于缓存中的不同位置，并可以反向推断内存地址（缓存中地址大致等同于内存地址的最末若干位，这种描述不精确，但足以描述这种方法的思想）。</p><ul><li>Column-ID-based data shuffling (shuffle data of each cache line differently)</li><li>Pattern ID – In-DRAM address translation (locally compute the column address at each chip)</li></ul><p>然而这个技术有一些明显缺陷：</p><ol type="1"><li>只能利用已经存储于行缓冲区中的数据放入缓存</li><li>不够灵活，只适用于特定形式，例如跨2的幂的读取</li><li>当行的大小增大时，效率减低，因为能同时利用的行数减少</li><li>数据库有多个表时，由于模式增多，复杂度提高</li></ol><h2 id="rc-dram">RC-DRAM</h2><p>RC-DRAM也称为双向可寻址DRAM。这也是一个很重要的内存架构，先前也学习了这个架构，以后如果有时间也需要总结。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/03/RC-NVM技术详解（上）/3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>RC-DRAM<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>是针对现有的DRAM单元进行的直接改进，每个单元含二晶体管、一电容，是完全对称的结构，在阵列级别上能够同时支持按行、按列的读取（并且完全对称）。</p><p>这使得按列的读取与按行的读取完全对称，解决了上述的问题。</p><p>这种方式需要解决的问题在于，缓存一致性协议需要修正，主要因为此处有两个方向的缓存，保持其同步需要额外的协议。</p><p>这种技术的主要问题在于：其各个单元面积的开销过大，甚至超过了直接复制两遍数据（一遍以行、一遍以列）方式的开销（面积开销超过两倍，同等面积容量不足一半）。</p><h2 id="crossbar架构">Crossbar架构</h2><p>基于Crossbar架构的非易失存储是一种主流技术，并且十分适于对称式存储器设计。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/03/RC-NVM技术详解（上）/5.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>图示为一8*32RRAM构成的Crossbar阵列。RRAM也可以用其它有非易失特性的器件（如PCM）替代。其中每个RRAM单元跨接在字线与位线的交点上，通过行线和列线上施加不同电平可以按行或按列进行读写，具体读写方式不在此赘述。</p><p>Crossbar架构的优势在于，每个非易失存储单元本身即完全对称，在架构中按行与按列的读写完全对称。与RC-DRAM相比，其不需要额外的晶体管用于行列读写的控制，因而它的额外面积开销显著更小。</p><p>RC-NVM就是采用Crossbar架构进行的设计。</p><h1 id="rc-nvm电路设计">RC-NVM电路设计</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/03/RC-NVM技术详解（上）/6.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>上图为RC-NVM的具体logic bank设计。除去基本的Crossbar阵列外，有一些外围电路。</p><p>字线与位线均连接到专用的解码器（decoder），感测放大器（sense amplifier, SA），写驱动器（write driver, WD）之上。这些连接均用多路复用器（multiplexer, MUX）控制，控制信号由内存控制器发出。除去已有的行缓冲区外，还要增加一个列缓冲区。</p><p>bank中划分为子阵列（subarray），这是用以按行、按列对称读写的基本读写单元。以行读为例，给定一个访问地址，全局的行解码器作部分解码，激活一个全局字线（global word line, GWL）和一个全局块线（global block line, GBL），然后局部行解码器最终发出一个one-hot信号（一位有效编码，指仅一位为1，其余位均0），激活一个局部字线（local word line, LWL），此后列解码器激活局部位线（local bit line, LBL），最终读出所要读的单元内的数据。随后感测放大器通过数据线（data line, DL）将数据送到行缓冲区。</p><p>这是一个经典的层级结构，能在规模增大时有效缓解延时和功耗。</p><p>这里会产生一个冲突：当同一个bank中的行与列缓冲区都存有数据中，该行与列交点处的数据被同时存于两个缓冲区中。这产生了经典的一致性问题，当一个缓冲区中该数据修改时，无法保证另一个缓冲区中同一数据被同步修改。这里，增加一个限制：<strong>行缓冲区与列缓冲区不能同时使用。</strong>当行或列缓冲区要使用时，我们关闭另一个正在使用的缓冲区，将数据写回。这避免了数据的一致性问题，代价是下一次被关闭的这一方向下一次读写时需要再从内存进行读写。然而实验结果表明，这样的代价影响不大。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/03/RC-NVM技术详解（上）/7.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/12/03/RC-NVM技术详解（上）/8.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>此两图显示了该电路设计的面积与延时特性。</p><p>上图是面积特性，横轴表示字线与位线的数目（方阵），纵轴为RC-DRAM与RC-NVM相比传统DRAM或NVM的面积多余开销，这里DRAM与RRAM被设定在同一工艺节点上，容量为4GB，具体评测方法参见文献。可见的是，RC-DRAM具有极大的额外开销（大于两倍），且在电路规模增大时，额外开销更大；但RC-NVM额外开销较小，主要来源于外围电路，因而随着规模扩大，额外开销的的比例在缩小。当字线与位线数为512时，额外面积开销小于20%。</p><p>下图为延时特性，延时的额外消耗主要来源于布线上的延迟，主要来自通过更多多路复用的晶体管。但是由于延时主要来自于单元的读写与走线的延时，经过仿真，延时开销在字线与列线为512的规模上增加仅约15%。</p><hr><p>下一篇中将介绍RC-NVM上层系统中的架构设计，主要涉及指令集、缓存协议的设计等。</p><h1 id="参考文献">参考文献</h1><section class="footnotes"><hr><ol><li id="fn1"><p>Wang, Peng, et al. &quot;RC-NVM: Enabling symmetric row and column memory accesses for in-memory databases.&quot; <em>2018 IEEE International Symposium on High Performance Computer Architecture (HPCA)</em>. IEEE, 2018.<a href="#fnref1" class="footnote-back">↩</a></p></li><li id="fn2"><p>Seshadri, Vivek, et al. &quot;Gather-scatter DRAM: in-DRAM address translation to improve the spatial locality of non-unit strided accesses.&quot; <em>Proceedings of the 48th International Symposium on Microarchitecture</em>. ACM, 2015.<a href="#fnref2" class="footnote-back">↩</a></p></li><li id="fn3"><p>Chen, Yen-Hao, and Yi-Yu Liu. &quot;Dual-addressing memory architecture for two-dimensional memory access patterns.&quot; <em>Proceedings of the Conference on Design, Automation and Test in Europe</em>. EDA Consortium, 2013.<a href="#fnref3" class="footnote-back">↩</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RC-NVM是指Row-Column Non-Volatile Memory，是一种新型的对称式非易失存储器架构。本文是HPCA 2018 &lt;em&gt;RC-NVM: Enabling symmetric row and column memory accesses for i
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Fisher Information</title>
    <link href="http://boltma.github.io/2019/05/02/Fisher-Information/"/>
    <id>http://boltma.github.io/2019/05/02/Fisher-Information/</id>
    <published>2019-05-02T14:49:24.000Z</published>
    <updated>2019-12-03T14:01:34.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fisher-information">Fisher Information</h1><p><strong>Fisher Information（费希尔信息）</strong>是用以衡量观测数据所蕴含的数据量，具体说来是指观测所得的随机变量<span class="math inline">\(X\)</span>携带的关于未知参数<span class="math inline">\(\theta\)</span>的信息量，其中<span class="math inline">\(X\)</span>的概率分布依赖于<span class="math inline">\(\theta\)</span>，通常记作<span class="math inline">\({\mathcal {I}}_{X}(\theta)\)</span>。</p><p>对于概率分布<span class="math inline">\(f(X;\theta)\)</span>（满足<span class="math inline">\(f(x;\theta )\geq0, \int f(x;\theta )dx=1,\quad\forall\theta\in\Theta\)</span>，<span class="math inline">\(\Theta\)</span>为参数集），称对数似然函数关于<span class="math inline">\(\theta\)</span>的偏导<span class="math inline">\(\frac {\partial }{\partial \theta }\log f(X;\theta )\)</span>为其<strong>得分</strong>（Score function），对于真实的参数<span class="math inline">\(\theta\)</span>，则有此得分的期望为0：</p><p><span class="math inline">\({\displaystyle {\begin{aligned}\operatorname {E} \left[\left.{\frac {\partial }{\partial \theta }}\log f(X;\theta )\right|\theta \right]&amp;=\int {\frac { {\frac {\partial }{\partial \theta }}f(x;\theta )}{f(x;\theta )}}f(x;\theta )\,dx\\&amp;={\frac {\partial }{\partial \theta }}\int f(x;\theta )\,dx\\&amp;={\frac {\partial }{\partial \theta }}1=0.\end{aligned}}}\)</span></p><p>并将得分的方差定义为<strong>费希尔信息</strong>：</p><p><span class="math inline">\({\displaystyle {\mathcal {I}}(\theta )=\operatorname {E} \left[\left.\left({\frac {\partial }{\partial \theta }}\log f(X;\theta )\right)^{2}\right|\theta \right]=\int \left({\frac {\partial }{\partial \theta }}\log f(x;\theta )\right)^{2}f(x;\theta )\,dx}\)</span></p><p>并且在密度函数具有良好性质的情况下，可以用分部积分很容易证明：</p><p><span class="math inline">\({\mathcal {I}}(\theta )=-\operatorname {E} \left[\left.{\frac {\partial ^{2}}{\partial \theta ^{2}}}\log f(X;\theta )\right|\theta \right]\)</span></p><p>这个表达式以如下方式表达了观测所携带的信息量：若对数似然函数较为平坦，则我们对<span class="math inline">\(\theta\)</span>的估计较差，反之，若对数似然函数有高而窄的峰，则我们可以得到对<span class="math inline">\(\theta\)</span>的较好估计，而这个性状由负二阶导数表征。</p><p>由于n个样本的对数似然函数为单个似然函数之和，容易证明，n个独立同分布样本的费希尔信息是单个样本的费希尔信息的n倍。</p><p>费希尔信息的三种观点：</p><ul><li>得分（对数似然函数的偏导）的方差</li><li>对数似然函数负二阶偏导的期望</li><li>最大似然估计渐近分布的方差的倒数</li></ul><h1 id="cramér-rao-bound">Cramér-Rao Bound</h1><p>费希尔信息的重要性在于<strong>Cramér-Rao不等式</strong>，或<strong>Cramér-Rao Bound（克拉美罗界）</strong>：</p><p>费希尔信息的倒数是参数<span class="math inline">\(\theta\)</span>的任何无偏估计<span class="math inline">\(\hat\theta\)</span>的方差的下界，即<span class="math inline">\(\operatorname {var} ({\hat {\theta }})\geq {\frac {1}{\mathcal {I}(\theta )}}\)</span></p><blockquote><p>关于参数<span class="math inline">\(\theta\)</span>的估计<span class="math inline">\(\hat\theta\)</span>的偏定义为估计的误差的期望值，即<span class="math inline">\(\operatorname {Bias} _{\theta }[\,{\hat {\theta }}\,]=\operatorname {E} _{\theta }[\,{\hat {\theta }}\,]-\theta =\operatorname {E} _{\theta }[\,{\hat {\theta }}-\theta \,]\)</span>，其中<span class="math inline">\(\operatorname {E} _{\theta }\)</span>表示期望是相对密度函数<span class="math inline">\(f(X;\theta)\)</span>而言的。</p><p>若对于所有<span class="math inline">\(\theta\in\Theta\)</span>，偏为0，则称此估计为无偏估计。</p><p>例如样本均值是总体均值的无偏估计量，样本方差是总体方差的无偏估计量，而标准差是总体标准差的有偏估计量。</p></blockquote><p>估计无偏并不能保证误差以极大的概率是低的。例如对于正态分布<span class="math inline">\({\mathcal {N}}(\theta ,1)\)</span>，设<span class="math inline">\(X_1,X_2,\cdots,X_n\)</span>是抽自它的独立同分布样本。估计<span class="math inline">\(\theta\)</span>时，<span class="math inline">\(X_1\)</span>与<span class="math inline">\(\bar {X_n}\)</span>均为无偏估计，然而显然使用更多数据会得到更好的估计，事实上也可以证明<span class="math inline">\(\bar {X_n}\)</span>是最小方差无偏估计量，也即达到了<strong>克拉美罗界</strong>。</p><p>达到克拉美罗界的无偏估计量优越于其他所有估计，也即<span class="math inline">\({\displaystyle \operatorname{E}[(\hat\theta_1(X_1,X_2,\cdots,X_n)-\theta)^{2}]\leq\operatorname{E}[(\hat\theta_2(X_1,X_2,\cdots,X_n)-\theta)^{2}]}\)</span>，若<span class="math inline">\(\hat\theta_1\)</span>达到了克拉美罗界。</p><p><strong>Cramér-Rao不等式的证明：</strong></p><p>设<span class="math inline">\(V\)</span>是得分函数，<span class="math inline">\(\hat\theta\)</span>是估计量。由Cauchy-Schwartz不等式，可得</p><p><span class="math display">\[\operatorname{E}_\theta[(V-\operatorname{E}_\theta V)(\hat\theta-\operatorname{E}_\theta\hat\theta)] \leq \operatorname{E}_\theta(V-\operatorname{E}_\theta V)^2\operatorname{E}_\theta(\hat\theta-\operatorname{E}_\theta \hat\theta)^2\]</span></p><p>由于<span class="math inline">\(\hat\theta\)</span>是无偏估计，所以对于任意<span class="math inline">\(\theta\)</span>均有<span class="math inline">\(\operatorname{E}_\theta \hat\theta=\theta\)</span>，同时得分函数的期望也为零（见上），并且结合费希尔信息的定义（<span class="math inline">\({\mathcal {I}}(\theta )=\operatorname {E}[V^2]\)</span>），代入上式有<span class="math inline">\(\operatorname {E}_\theta[V\hat\theta]\leq\mathcal{I}(\theta)\operatorname{var}(\hat\theta).\)</span></p><p>而</p><p><span class="math display">\[{\displaystyle \begin{aligned} \operatorname {E}_\theta[V\hat\theta]&amp;=\int\frac{\frac{\partial}{\partial\theta}f(x;\theta)}{f(x;\theta)}\hat\theta(x)f(x;\theta)dx \\ &amp;= \int \frac{\partial}{\partial\theta} f(x;\theta)\hat\theta(x)dx \\ &amp;= \frac{\partial}{\partial\theta}\int f(x;\theta)\hat\theta(x)dx \\ &amp;= \frac{\partial}{\partial\theta} \operatorname{E}_\theta[\hat\theta] \\ &amp;= \frac{\partial}{\partial\theta}\theta = 1\end{aligned}}\]</span></p><p>（这里能交换积分与微分号是假定密度函数具有良好性质，上同）</p><p>代入即得到Cramér-Rao不等式。 <span class="math inline">\(\square\)</span></p><p>以相同的证明方式可以得到对于任意估计量有<span class="math inline">\(\operatorname {var} \left({\hat {\theta }}\right)\geq {\frac {[1+b&#39;(\theta )]^{2}}{\mathcal{I}(\theta )}}\)</span>，此处<span class="math inline">\(b(\theta)=\operatorname{E}_\theta[\hat\theta]-\theta.\)</span></p><h1 id="多参数情形的fisher-information">多参数情形的Fisher Information</h1><p>多参数下有<strong>费希尔信息矩阵</strong><span class="math inline">\(\mathcal{I}(\theta)\)</span>，其中元素为<span class="math inline">\(\mathcal{I}_{m,k}=\operatorname {E} \left[{\frac {\partial }{\partial \theta _{m}}}\log f\left(x;\theta\right){\frac {\partial }{\partial \theta _{k}}}\log f\left(x;\theta\right)\right]=-\operatorname {E} \left[{\frac {\partial ^{2}}{\partial \theta _{m}\partial \theta _{k}}}\log f\left(x;\theta\right)\right]\)</span></p><p><strong>Cramér-Rao不等式</strong>变为：<span class="math inline">\(\Sigma\geq\mathcal{I}^{-1}(\theta)\)</span>，这里矩阵不小于号指差是半正定的，<span class="math inline">\(\Sigma\)</span>是关于<span class="math inline">\(\theta\)</span>的一组无偏估计量的协方差矩阵。</p><h1 id="与其它散度测度的关系">与其它散度测度的关系</h1><h2 id="与熵的关系">与熵的关系</h2><p>以<span class="math inline">\(f(x)\)</span>为密度函数的随机变量<span class="math inline">\(X\)</span>的微分熵（differential entropy）定义为：</p><p><span class="math display">\[h(x)=-\int_{S}f(x)\log f(x)dx\]</span> 对<span class="math inline">\(\epsilon&gt;0\)</span>及任意<span class="math inline">\(n\)</span>，定义<span class="math inline">\(f(x)\)</span>的典型集<span class="math inline">\(A_{\epsilon}^{(n)}\)</span>如下：</p><p><span class="math display">\[\begin{aligned} A_{\epsilon}^{(n)}=\{&amp;(x_1,x_2,\cdots,x_n)\in S^n: \\ &amp;\left|-\frac{1}{n}\log f(x_1,x_2,\cdots,x_n)-h(X)\right|\leq\epsilon \} \end{aligned}\]</span> 这里<span class="math inline">\(f(x_1,x_2,\cdots,x_n) = \prod\limits_{i=1}^{n}f(x_i)\)</span></p><p>典型集是所有概率<span class="math inline">\(\geq1-\epsilon\)</span>的集合中体积最小的。</p><p>熵表征了典型集的体积（典型集体积渐近趋于<span class="math inline">\(2^{nh}\)</span>，其中<span class="math inline">\(h\)</span>为熵），而费希尔信息与典型集的表面积相关。</p><h2 id="de-bruijn恒等式">de Bruijn恒等式</h2><p>设<span class="math inline">\(X\)</span>为任一随机变量，其密度函数为<span class="math inline">\(f(x)\)</span>且方差有限。令<span class="math inline">\(Z\)</span>是与<span class="math inline">\(X\)</span>独立的正态分布的随机变量，均值为0，方差为1。则：</p><p><span class="math display">\[\frac{\partial}{\partial t}h_e(X+\sqrt{t}Z)=\frac{1}{2}\mathcal{I}(X+\sqrt{t}Z)\]</span></p><p>此处<span class="math inline">\(h_e\)</span>表明微分熵公式中底数为<span class="math inline">\(e\)</span>，费希尔信息是关于随机变量分布的费希尔信息。特别地，若<span class="math inline">\(t\rightarrow 0\)</span>时极限存在，则<span class="math inline">\(\frac{\partial}{\partial t}h_e(X+\sqrt{t}Z)\big|_{t=0}=\frac{1}{2}\mathcal{I}(X)\)</span></p><p>通常<span class="math inline">\(t\)</span>被视作一种扰动。</p><h2 id="卷积不等式">卷积不等式</h2><p><span class="math display">\[\frac{1}{\mathcal{I}(X+Y)} \geq \frac{1}{\mathcal{I}(X)} + \frac{1}{\mathcal{I}(Y)}\]</span></p><h2 id="熵幂不等式">熵幂不等式</h2><p>设<span class="math inline">\(\mathbf{X}\)</span>和<span class="math inline">\(\mathbf{Y}\)</span>为相互独立的<span class="math inline">\(n\)</span>维随机向量，它们的密度函数已知，则：</p><p><span class="math display">\[2^{\frac{2}{n}h(\mathbf{X}+\mathbf{Y})}\geq 2^{\frac{2}{n}h(\mathbf{X})}+2^{\frac{2}{n}h(\mathbf{Y})}\]</span></p><p>对于两个独立的随机变量<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>，<span class="math inline">\(h(X+Y)\geq h(X&#39;+Y&#39;)\)</span>，这里<span class="math inline">\(X&#39;\)</span>和<span class="math inline">\(Y&#39;\)</span>是相互独立的正态分布的随机变量，且满足<span class="math inline">\(h(X&#39;)=h(X)\)</span>且<span class="math inline">\(h(Y&#39;)=h(Y)\)</span>。</p><h1 id="fisher-information-natural-gradient">Fisher Information &amp; Natural Gradient</h1><p>在概率分布函数具备良好性质时，Fisher信息矩阵和KL散度的Hesse矩阵的相反数相等。因而在牛顿迭代法中，使用Fisher信息矩阵代替Hesse矩阵，有时更易求解。</p><blockquote><p><strong>Natural Gradient（自然梯度法）</strong></p><p><span class="math display">\[{\displaystyle \theta _{m+1}=\theta _{m}+\eta_m{\mathcal {I}}^{-1}(\theta _{m})V(\theta _{m})}\]</span></p><p>（<span class="math inline">\(V\)</span>为关于<span class="math inline">\(\theta\)</span>的得分函数）</p></blockquote><p>自然梯度法考虑了参数的不同维度对目标函数不同的影响，加速了梯度下降法的收敛。</p><p>SGD（随机梯度下降）中，假设中心极限定理，随机梯度作为一个随机变量，满足正态分布。那么迭代中，相当于使用全部数据计算的梯度，附加上协方差矩阵，即：（<span class="math inline">\(t\)</span>为mini-batch的规模）</p><p><span class="math display">\[{\displaystyle \theta _{m+1}=\theta _{m}+\eta_m V_0(\theta _{m})}+\frac{\eta_m}{\sqrt{t}}\epsilon_m, \epsilon_m\sim\mathcal{N}(0,\hat{\Sigma}(\theta_m))\]</span></p><p>上式中，协方差与目标函数的曲率在真实参数上相等。而在迭代过程中也近似相等。</p><p>这表明这样的SGD中的噪声遵循目标函数的曲率，使得迭代时更容易逃离局部的sharp minima，进入flat minima，从而得到泛化能力更强的解。因而使用自然梯度的随机梯度下降能获得更强的泛化能力，也通常能加快迭代速度。</p><h1 id="references">References</h1><ol type="1"><li><p>Wikipedia contributors, &quot;Fisher information —— Wikipedia, the free encyclopedia,&quot; 2019. [Online; accessed 24-May-2019].</p></li><li><p>T. M. Cover and J. A. Thomas, <em>Elements of information theory.</em> John Wiley &amp; Sons, 2012.</p></li><li><p>J. Duchi, &quot;Lecture notes for statistics 311/electrical engineering 377,&quot; URL:<a href="https://stanford.edu/class/stats311/Lectures/full_notes.pdf" class="uri" target="_blank" rel="noopener">https://stanford.edu/class/stats311/Lectures/full_notes.pdf</a> . Last visited on, vol. 2, p. 23, 2016.</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;fisher-information&quot;&gt;Fisher Information&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Fisher Information（费希尔信息）&lt;/strong&gt;是用以衡量观测数据所蕴含的数据量，具体说来是指观测所得的随机变量&lt;span clas
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>形式语言与自动机</title>
    <link href="http://boltma.github.io/2019/03/24/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <id>http://boltma.github.io/2019/03/24/形式语言与自动机/</id>
    <published>2019-03-24T01:54:17.000Z</published>
    <updated>2019-12-03T14:01:34.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="上下文无关文法">上下文无关文法</h1><h2 id="设计上下文无关文法">设计上下文无关文法</h2><ol type="1"><li><p>{a<sup>n</sup>b<sup>n</sup>c<sup>m</sup>d<sup>m</sup>|n≥1,m≥1}∩{a<sup>n</sup>b<sup>m</sup>c<sup>m</sup>d<sup>n</sup>|n≥1,m≥1}</p><p>S-&gt;AB|T T-&gt;aTd|aCd A-&gt;aAb|ab B-&gt;cBd|cd C-&gt;bCc|bc</p></li><li><p>{a<sup>n</sup>b<sup>m</sup>|n,m≥0∧n≥m}</p><p>S-&gt;A|B A-&gt;aA|aC B-&gt;Bb|Cb C-&gt;aCb|ε</p></li><li><p>{a<sup>n</sup>b<sup>m</sup>|n≥0,m≥0,3n≥m≥2n}</p><p>S-&gt;aSbb|aSbbb|ε</p></li><li><p>{w|w∈{a,b}<sup>*</sup>,w中a和b的数目不同}</p><p>S-&gt;A|B A-&gt;AA|Ta B-&gt;BB|Tb T-&gt;aTbT|bTaT|ε 注意此处T生成a与b数目相同的字符串</p></li><li><p>{w|w∈{a,b}<sup>*</sup>,且w中a与b的数目相差为2}</p><p>S-&gt;TaTaT|TbTbT T-&gt;aTbT|bTaT|ε</p></li></ol><h2 id="文法和语言中的二义性">文法和语言中的二义性</h2><p><em>文法无二义性：语法分析树唯一，亦等价于最左推导唯一</em></p><ol type="1"><li><p>下面的文法生成的是具有x和y的操作数、二元运算符+、-和*的前缀表达式：</p><p>E-&gt;+EE|*EE|-EE|x|y</p><p>证明这个文法是无歧义的。（Hopcroft, 5.4.7(b)）</p><p>提纲：可证明其最左推导是唯一的，对字符串长度归纳，同时归纳证明生成的字符串w所有非空后缀字符串中操作数个数多于运算符个数。</p></li></ol><h1 id="有限自动机">有限自动机</h1><p>安利一个用来画自动机的app：<a href="http://madebyevan.com/fsm/" class="uri" target="_blank" rel="noopener">http://madebyevan.com/fsm/</a></p><h2 id="设计dfa">设计DFA</h2><ol type="1"><li>长度至少为2且头两个字符不相同的0,1串构成的集合</li></ol><table><thead><tr class="header"><th></th><th>0</th><th>1</th></tr></thead><tbody><tr class="odd"><td>-&gt;q0</td><td>q1</td><td>q2</td></tr><tr class="even"><td>q1</td><td>q4</td><td>q3</td></tr><tr class="odd"><td>q2</td><td>q3</td><td>q4</td></tr><tr class="even"><td>*q3</td><td>q3</td><td>q3</td></tr><tr class="odd"><td>q4</td><td>q4</td><td>q4</td></tr></tbody></table><ol start="2" type="1"><li>{w∈{a,b}<sup>*</sup>|w中不包含子串aa}</li></ol><table><thead><tr class="header"><th></th><th>a</th><th>b</th></tr></thead><tbody><tr class="odd"><td>-&gt;*q0</td><td>q1</td><td>q0</td></tr><tr class="even"><td>*q1</td><td>q2</td><td>q0</td></tr><tr class="odd"><td>q2</td><td>q2</td><td>q2</td></tr></tbody></table><ol start="3" type="1"><li>{w∈{a,b}<sup>*</sup>|w中包含且仅包含奇数个子串ab}</li></ol><table><thead><tr class="header"><th></th><th>a</th><th>b</th></tr></thead><tbody><tr class="odd"><td>-&gt;q0</td><td>q1</td><td>q0</td></tr><tr class="even"><td>q1</td><td>q1</td><td>q2</td></tr><tr class="odd"><td>*q2</td><td>q3</td><td>q2</td></tr><tr class="even"><td>q3</td><td>q3</td><td>q0</td></tr></tbody></table><ol start="4" type="1"><li>{w∈{a,b}<sup>*</sup>|w中a的个数和b的个数之和是奇数}</li></ol><table><thead><tr class="header"><th></th><th>a</th><th>b</th></tr></thead><tbody><tr class="odd"><td>-&gt;q0</td><td>q1</td><td>q1</td></tr><tr class="even"><td>*q1</td><td>q0</td><td>q0</td></tr></tbody></table><ol start="5" type="1"><li>{w∈{a,b}<sup>*</sup>|w含相同个数的a和b,且w的每个前缀中a和b个数之差不超过1}</li></ol><table><thead><tr class="header"><th></th><th>a</th><th>b</th></tr></thead><tbody><tr class="odd"><td>-&gt;*q0</td><td>q1</td><td>q2</td></tr><tr class="even"><td>q1</td><td>q3</td><td>q0</td></tr><tr class="odd"><td>q2</td><td>q0</td><td>q3</td></tr><tr class="even"><td>q3</td><td>q3</td><td>q3</td></tr></tbody></table><ol start="6" type="1"><li>{w∈{a,b}<sup>*</sup>|w包含子串ab，但不包含子串bb}</li></ol><p><img src="/2019/03/24/形式语言与自动机/dfa-1.png"></p><p>相应的NFA有：</p><p><img src="/2019/03/24/形式语言与自动机/nfa-1.png"></p><p>此NFA遇到子串ab时到达终态，如果是最后一个ab，则停留在终态，反之跳转回q1。</p><h2 id="dfa的最小化">DFA的最小化</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/24/形式语言与自动机/dfa-2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>构造与该DFA等价的最小化的DFA：</p><p>填表算法第一步区分1，3，6与2，4，5</p><p>第二步区分2与4，5（输入字符b）</p><p>第三步区分1，3与6（输入字符a）</p><p>故最终等价类有{1, 3}, {2}, {4, 5}, {6}</p><p>最小化的DFA是</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/24/形式语言与自动机/dfa-3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="正规语言">正规语言</h1><h2 id="设计正规语言">设计正规语言</h2><ol type="1"><li><p>{xwx<sup>R</sup>|x,w∈(a+b)+},其中(a+b)<sup>+</sup>=(a+b)(a+b)<sup>*</sup>,x<sup>R</sup>为x的反向(即反转)</p><p>a(a+b)(a+b)<sup>*</sup>a+b(a+b)(a+b)<sup>*</sup>(a+b)</p></li><li><p>{w|w∈{a,b}<sup>*</sup>∧∃x,y(x,y∈{a,b}<sup>*</sup>∧w=xy∧|y|=3∧y=y<sup>R</sup>)}</p><p>(a+b)<sup>*</sup>(aaa+aba+bab+bbb)</p></li><li><p>{w∈{a,b}<sup>*</sup>|w中既不包含子串aa,也不包含子串bb}</p><p>(ε+b)(ab)<sup>*</sup>(ε+a)</p></li><li><p>{a<sup>n</sup>b<sup>m</sup>|n,m≥0且n+m为偶数}</p><p>(aa)<sup>*</sup>(bb)<sup>*</sup>+(aa)<sup>*</sup>a(bb)<sup>*</sup>b</p></li><li><p>{w|w∈{a,b}<sup>*</sup>,|w|≥1,且w的后20位至少有一个a}</p><p>(a+b)<sup>*</sup>a(a+b+ε)<sup>19</sup></p></li><li><p>{w|w∈{a,b}<sup>*</sup>,|w|≥1,且当w以a结尾时,它的长度为奇数}</p><p>((a+b)(a+b))<sup>*</sup>a+(a+b)<sup>*</sup>b</p></li><li><p>{w|w∈{a,b}<sup>*</sup>,|w|≥2,且w的前5位至少有一个子串aa}</p><p>(a+b+ε)<sup>3</sup>aa(a+b)<sup>*</sup></p></li><li><p>{w|w∈{a,b}<sup>*</sup>,|w|≥2,且w的第2位至第5位至少有一个a}</p><p>(a+b)(a+b+ε)<sup>3</sup>a(a+b)<sup>*</sup></p></li><li><p>{w|w∈{0,1}<sup>*</sup>,w至少含有3个1,且倒数第3位为1}</p><p>(0+1)<sup>*</sup>1(0+1)<sup>*</sup>1(0+1)<sup>*</sup>100+(0+1)<sup>*</sup>1(0+1)<sup>*</sup>1(01+10)+(0+1)<sup>*</sup>111</p></li></ol><h2 id="有限状态自动机与正规表达式的关系">有限状态自动机与正规表达式的关系</h2><h3 id="thompson构造法">Thompson构造法</h3><p>略</p><h3 id="kleene构造法状态消去法">Kleene构造法&amp;状态消去法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/24/形式语言与自动机/dfa-4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>运用状态消去法，消2，1到4的弧变为b(a+b)，4到自身的弧变为(a+b)<sup>2</sup></p><p>最终的正则表达式为a<sup>*</sup>+a<sup>*</sup>b(a+b)((a+b)<sup>2</sup>)<sup>*</sup></p><h2 id="正规语言的性质">正规语言的性质</h2><ol type="1"><li><p>语言L由所有满足如下条件的0，1串构成：0的数目二倍于1的数目。试应用Pumping引理证明L不是正规语言。</p><p>对于任意n，取w=0<sup>2n</sup>1<sup>n</sup>，任意满足w=xyz∧|xy|≤n∧y≠ε的x，y，z必有y全由0组成，则xy<sup>0</sup>z中0比1的两倍少，不在L中，L不是正规语言。</p></li><li><p>语言L由所有满足如下条件的0, 1串构成：0的数目多于1的数目（ 对0 和1 在串中出现的次序没有限制）。试应用Pumping引理证明L不是正规语言。</p><p>选w=0<sup>n+1</sup>1<sup>n</sup></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;上下文无关文法&quot;&gt;上下文无关文法&lt;/h1&gt;
&lt;h2 id=&quot;设计上下文无关文法&quot;&gt;设计上下文无关文法&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;{a&lt;sup&gt;n&lt;/sup&gt;b&lt;sup&gt;n&lt;/sup&gt;c&lt;sup&gt;m&lt;/sup&gt;d&lt;sup&gt;m&lt;/sup
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello, world!</title>
    <link href="http://boltma.github.io/2019/03/24/Hello-world/"/>
    <id>http://boltma.github.io/2019/03/24/Hello-world/</id>
    <published>2019-03-24T01:53:12.000Z</published>
    <updated>2019-12-03T14:01:34.854Z</updated>
    
    <content type="html"><![CDATA[<p>这里会记录一些学习笔记，或者灌水，请多多指教！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里会记录一些学习笔记，或者灌水，请多多指教！&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
